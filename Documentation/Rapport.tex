\documentclass[a4paper]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{enumitem}
\usepackage[babel=true]{csquotes}

\pagestyle{plain}

\title{
	\textbf{Rapport de projet}
	\bigskip
	\begin{center}
		\includegraphics[scale=0.25]{img/OpenSculpt.png}
	\end{center}
}
\author{\emph{GAUTHIER Silvère}\\\emph{LAMEIRA Yannick}\\\emph{PELADAN Cécile}}
\date{\today}
\setcounter{tocdepth}{2}

\begin{document}
	\maketitle
	\newpage
	\tableofcontents

	\chapter{Remerciements}

		Un grand merci à Frédéric Boudon et Benjamin Gilles pour leur encadrement.
		Un remerciement particulier à Frédéric Boudon pour son idée d'outil de subdivision locale.

	\chapter{Introduction}
		
		\section{Sujet initial}
			L'objectif de ce projet est de créer un logiciel de sculpture 3D. L'utilisateur aurait à disposition un maillage déformable, qu'il pourrait 
			modeler avec différents outils tels que déplacement, ajout de matière ou lissage. L'interface devra permettre à l'utilisateur de facilement 
			créer un maillage initial, le visualiser et interagir avec lui à l'aide des différents outils de modelage. Initialement, les premières 
			fonctionnalités à implémenter seront la création d'une sphère ou d'un cube comme maillage de départ, la navigation dans l'espace 3D pour se 
			positionner autour du maillage, puis les outils de déformation cités ci-dessus. Une interface graphique contenant les boutons d'outils sera 
			définie pour que l'utilisateur puisse intuitivement appliquer les différentes opérations proposées.

			Les principales difficultés ici seront d'abord de gérer correctement l'interaction 3D de l'utilisateur avec le maillage via le curseur et la 
			fenêtre 2D. Ensuite viendra la mise en place d'une structure de données efficace et robuste de maillage avec l'implémentation des algorithmes 
			de subdivision et de raffinement.

			Si le temps le permet, d'autres outils et maillages de base pourront être implémentés, afin d'enrichir le logiciel. On pourra également 
			réfléchir à une manière d'importer et exporter les maillages sous différents formats tels que le OBJ ou le STL par exemple.

			Ce logiciel sera développé en C++ avec la bibliothèque OpenGL pour le rendu 3D et la bibliothèque Qt pour définir l'interface.

%==========================================================================================================================================================
	\chapter{Cahier des charges}
		Ce chapitre détaille la phase de conception du projet.
			
		\section{Mécanismes}
			Cette section détaille succintement les fonctionnalités de l'application.
			
			\subsection{Les Modèles}
				\label{model-cdc}
				Différents maillages prédéfinis, appelés ici modèles, sont mis à disposition de l'utilisateur.\\
				Nous en prévoyons actuellement cinq, paramétrables par l'utilisateur :
				\begin{itemize}
					\item \textbf{Cube :} défini par une largeur, une hauteur et une profondeur.
					\item \textbf{Sphère :} défini par un rayon.
					\item \textbf{Cylindre :} défini par une hauteur et un rayon.
					\item \textbf{Cône :} défini par une hauteur et un rayon.
					\item \textbf{Tore :} défini par un rayon horizontal et un rayon vertical.
				\end{itemize}
				Chaque modèle est aussi paramétré par un pas de discrétisation.
				
			\subsection{Le Rendu}
				Le rendu s'effectue dans une classe spécifique, et permet de synchroniser la structure interne des maillages avec les buffer objects. Il 
				existe également différentes options de rendu telles que l'affichage solide ou en fils de fer, les couleurs, les lumières...etc.

			\subsection{Les Outils de sculpture}
				\label{tool-cdc}
				Différents outils sont disponibles. Ils ont pour action de modifier le maillage dans la direction des normales de surface, et selon
				un schéma de modification propre à chaque outil. Nous avons défini deux catégories d'outils : modifications globales et locales des objets
				(une troisième est destinée au déplacement de la caméra dans la scène en trois dimensions).
				\newpage
				\begin{itemize}
					\item \textbf{Modifications Globales :}
					\begin{itemize}
						\item \textbf{GTMove :} Déplacement d'un objet dans le repère scène.
						\item \textbf{GTRotate :} Rotation d'un objet dans le repère scène.
						\item \textbf{GTScale :} Mise à l'échelle d'un objet dans le repère scène.
					\end{itemize}
					\item \textbf{Modifications Locales :}
					\begin{itemize}
						\item \textbf{LTAdd :} Ajout de matière à la surface de l'objet.
						\item \textbf{LTSmooth :} Lissage de la surface de l'objet.
						\item \textbf{LTMove :} Déplacement d'une partie des points de la surface de l'objet.
						\item \textbf{LTInflate :} Gonflement de la surface de l'objet.
						\item \textbf{LTPinch :} Pincement de la surface de l'objet.
					\end{itemize}
				\end{itemize}
				Pour plus de détails sur leur fonctionnement, référez-vous à la partie \textbf{Développement} (cf page \pageref{tool-dev}).

			\subsection{Les Algorithmes de maillage}
				Les différents algorithmes de modification de maillages sont regroupés dans une classe statique spécifique. Y sont présentes les 
				fonctions de subdivision et de décimation globale, ainsi qu'une subdivision et une décimation automatique paramétrable avec une longueur 
				(maximale ou minimale) d'arête.

			\subsection{Interface}
				L'interface de l'application doit être ergonomique et proposer de nombreux raccourcis clavier afin de permettre à l'utilisateur de 
				travailler rapidement. Elle doit également être le plus intuitive possible, car un tel logiciel pourrait devenir très compliqué à 
				appréhender. Cela concerne tant les dispositions que les icônes qui doivent suivre une certaine logique.

			\subsection{Les Options}
				Différentes options sont disponibles, telles que créer un nouveau projet, ouvrir, enregistrer, importer ou exporter un projet, annuler ou 
				refaire une action utilisateur...etc. De même, certaines options de rendu telles que le mode fils de fer sont présentes.
	
		\section{Structure du programme}
			Cette partie détaille succintement la structure globale du logiciel, ce qui couvre les aspects non maîtrisables par l'utilisateur.
			
			\subsection{L'API}
				L'application doit contenir une surcouche, ayant pour objectif de rendre notre logiciel facilement extensible par d'autres développeurs, 
				sans qu'ils n'aient besoin de connaître tous les détails de la structure interne de celui-ci.
				
				La structure interne des maillages retenue ici est la structure par demi-arêtes. Nous avons donc, pour chaque maillage, des listes de 
				points, faces et demi-arêtes.\\ Chaque point contient des coordonnées en trois dimensions, un indice de position dans la liste afin 
				d'améliorer la vitesse d'accès, ainsi qu'un pointeur vers une demi-arête sortante.\\ Chaque face contient un pointeur vers une demi-arête 
				intérieure, et éventuellement un vecteur normal.\\ Chaque demi-arête contient des pointeurs vers : une face, un point, les demi-arêtes 
				suivantes et précédentes au sein de la même face, et la demi-arête opposé.
				
				Plusieurs méthodes publiques doivent être présentes, telles que "ajouter une face", "couper une arête en deux", "fusionner deux arêtes"... 
				et cacher la structure interne (n'agir qu'à l'aide de coordonnées par exemple). Cela permettra dans le futur, si besoin, de changer la 
				structure interne sans modifier le reste de l'application.
		
%==========================================================================================================================================================
	\chapter{Gestion du projet}
		Cette partie traite globalement de tout ce qui concerne l'organisation du projet, que ce soit au niveau de la conception, du développement, de 
		l'équipe ou encore de la gestion des fichiers.
		
		\section{Gestion de l'équipe}
			Tous les membres se connaissant et étant supposés être capable de travailler en équipe, nous n'avons fait aucune élection préalable de chef de 
			projet.\\ Mais le déroulement du projet nous a imposé ce choix, GAUTHIER Silvère assure donc ce rôle, afin de garder une cohésion de groupe 
			et assurer la réalisation de nos objectifs.\\ Chaque membre peut tout de même participer activement au projet, autant lors de la conception que 
			du développement. Toutes les décisions sont prises suivant la majorité lors de votes.\\\\
			Pour ce qui est des réunions de projets, nous avons convenu avec nos tuteurs d'une réunion, allant d'environ trente minutes à une heure, toutes 
			les semaines, afin de mettre au point l'avancement du projet. En parallèle, tous les membres de notre équipe se retrouvent une fois par semaine 
			afin de discuter des points clés effectués ou à venir, donner lieu aux votes pour les prises de décisions, ou encore, lors de la phase de 
			développement, travailler en collaboration afin d'optimiser notre travail.\\\\
			Au niveau du travail collaboratif, nous avons mis en place un dépôt sur github (adresse à la page \pageref{url:github}), contenant tant la 
			documentation que les sources de notre programme. Par ailleurs, nous mettons sur ce dépôt uniquement les fichiers sources et les images, mais 
			en aucun cas les fichiers temporaires ou les exécutables. Les seuls fichiers binaires disponibles sont les PDF de la documentation, pour un 
			soucis de facilité d'accès et de lecture.

		\section{Découpage en tâches}
			Afin de préparer le développement du programme, il était nécessaire de séparer les fonctionnalités les unes des autres. Nous avons abouti à ce 
			diagramme, qui résume notre choix de découpage :\\
			\begin{figure}[H]
				\begin{center}
					\includegraphics[scale=0.5]{img/DiagrammeDecoupageProjet.png}
				\end{center}
				\label{fig:decoupage}
				\caption{Diagramme des tâches du projet}
			\end{figure}

		\section{Assignation}
			Le projet étant découpé en un certain nombre de modules, il ne restait plus qu'à assigner chaque tâche à un ou plusieurs membres de l'équipe. 
			Nous nous sommes organisés comme ceci :
			\begin{itemize}[label=$\bullet$]
				\item \textbf{Conception, implémentation et vérifications de l'API} : GAUTHIER Silvère.
				\item \textbf{Mise en place de l'interface} : LAMEIRA Yannick.
				\item \textbf{Implémentation des maillages modèles} : PELADAN Cécile.
				\item \textbf{Conception et implémentation des outils} : GAUTHIER Silvère, LAMEIRA Yannick, PELADAN Cécile.
				\item \textbf{Tests et vérifications de l'application} : GAUTHIER Silvère, LAMEIRA Yannick, PELADAN Cécile.
			\end{itemize}
			Bien entendu, les membres peuvent évidemment faire appel aux autres pour trouver une solution à un problème par exemple.\\
			Le détail complet des tâches et assignations se situe dans la section Gestion du temps, page \pageref{GestionTps}.

		\section{Gestion du temps}
			\label{GestionTps}
			Afin de clarifier notre gestion du temps, deux diagrammes de Gantt (prédictif et final) sont disponibles en annexe (cf page \pageref{fig:gantt}) 
			et dans la documentation de notre projet.

		\section{Choix technologiques}
			Afin de pouvoir développer correctement notre logiciel, il a fallu définir tout ce que nous allions utiliser en terme de langages et 
			bibliothèques selon notre logique de conception.
			
			\subsection{Langages de programmation}
				Pour des besoins de performances, nous avons comparé différents langages. Pour réduire le temps de recherche et de comparaison, nous nous 
				sommes appuyé sur des tests déjà effectués par d'autre.\\ Des tests de performances concernant un large panel de langages, comparés dans 
				quatre contextes différents, sont fournis en annexe, page \pageref{fig:analyse}.\\ Nous pouvons observer que globalement, le langage le plus 
				rapide est ici C++. L'utilisation de ce langage étant très fréquente dans les applications en temps réel, de part sa réputation d'un des 
				langages les plus performants, et tous les membres de notre équipe sachant l'utiliser, nous avons fait le choix de programmer le logiciel en 
				C++.\\

			\subsection{Bibliothèques}
				Pour la gestion graphique de l'interface et de l'affichage de l'objet, nous avons cherché une bibliothèque relativement simple d'utilisation 
				mais surtout performante afin de garder la fluidité gagnée avec le choix des langages de programmation.\\ Connaissant la bibliothèque 
				OpenGL, qui est bas niveau et performante dans les affichages deux et trois dimensions, nous nous sommes tournés vers une bibliothèque 
				utilisant OpenGL : Qt.\\

			\subsection{Représentation du maillage}
				Nous cherchons ici à comparer différentes techniques permettant de représenter un maillage, afin de choisir celle qui est la plus adaptée à 
				nos opérations. Voici un tableau récapitulatif de cette étude comparative :
				\begin{table}[H]
					\begin{small}
						\hspace{-2,5cm}
						\begin{tabular}{| c | l | l |}
							\hline
							\textbf{Représentation} & \textbf{Avantages} & \textbf{Inconvénients}\\
							\hline
							 & - Hiérarchie des résolutions & - Visualisation surfacique difficile\\
							Octree ou KDTree & - Rendu volumique possible & - Coût de stockage excessif\\
							 & - Construction et parcours simples & - Recalculer à chaque modification\\
							\hline
							 & - Historique de construction & - Non unicité\\
							Arbre CSG & - Approche fonctionnelle & - Opérations complexes\\
							 &  & - Domaine insuffisant\\
							\hline
							G-maps & - Opérations de topologie simples & - Séparation topologie / plongement\\
							 & - Plongements multiples & \\
							\hline
							Liste de triangles & - Opérations simples & - Stockage non optimisé\\
							\hline
							Sommets partagés & - Opérations simples & \\
							 & - Stockage correct & \\
							\hline
							Bandes de triangles & - Stockage correct & - Chaque sommet est visité deux fois\\
							 &  & - Opérations de déplacement délicates\\
							\hline
							Structure par faces & - Chaque face pointe sur ses sommets & - Pas d'accès direct aux arêtes\\
							 & - Une face connaît les faces adjacentes & \\
							\hline
							Structure par demi-arêtes & - Parcours de maillage très pratiques & - Coût de stockage excessif\\
							\hline
							Vertex Array (VAO) & - Optimisé pour le rendu OpenGL & - Utilise le CPU et la RAM\\
							 & - Simple d'utilisation & \\
							\hline
							Vertex Buffer Object (VBO) & - Optimisé pour le rendu OpenGL & \\
							 & - Utilise le GPU et la VRAM & \\
							\hline
						\end{tabular}
					\end{small}
					\label{tab:maillage}
					\caption{Tableau comparatif de méthodes de représentation de maillage 3D}
				\end{table}
				L'étude comparative montre qu'il serait judicieux d'utiliser conjointement des Vertex Buffer Objects (VBOs) afin d'optimiser les 
				performances d'affichage et une classe personnalisée pour aisément gérer nos données par une surcouche de méthodes. La structure interne des 
				maillages choisie est donc une structure de type demi-arêtes, afin de faciliter les opérations de voisinage.
			
		\section{Gestion des fichiers}
			Nous avons beaucoup de fichiers à gérer dans ce projet, et nous devions établir des conventions ou des moyens afin de les gérer correctement.
			
			\subsection{Format des Fichiers}
				Le code étant écrit en C++, nous utilisons des fichiers d'en-tête au format H et des fichiers de définition au format CPP.\\
				Toutes les images nécessaires au logiciel sont au format PNG afin de pouvoir utiliser la transparence et garder la pleine qualité d'image 
				(contrairement à JPEG qui perd de l'information à la compression).\\
			
				\subsubsection{Sauvegarde}
					Une façon judicieuse de sauvegarder nos données est d'avoir un format spécial pour enregistrer un projet complet contenant une liste 
					d'objets, ainsi qu'une possibilité d'exportation de chaque objet ou scène dans un format connu tel que STL ou OBJ.
			
			\subsection{Commentaires}
				Si une méthode ou fonction (voir même un bloc) dépasse une certaine taille ou devient trop compliquée, un commentaire est ajouté avant 
				celle-ci expliquant brièvement son processus :
				\begin{verbatim}
					/** Description :
					*** Entrée : ...
					*** Sortie : ...
					**/
				\end{verbatim}
				Quelque commentaires précieux pour le travail collaboratif sont également présents :
				\begin{table}[H]
					\begin{small}
						\hspace{-0,5cm}
						\begin{tabular}{| c | c |}
							\hline
							\textbf{Marqueur spécifique} & \textbf{Signification}\\
							\hline
							TODO & A mettre à la place du code d'une fonctionnalité à implémenter\\
							\hline
							RECODE & A mettre au dessus du bloc d'une fonctionnalité à refaire ou à optimiser\\
							\hline
							FIXME & A mettre au dessus du bloc d'une fonctionnalité contenant un bug\\
							\hline
						\end{tabular}
					\end{small}
					\label{tab:commentaire}
					\caption{Forme et usage des commentaires}
				\end{table}

			\subsection{Conventions de Nommage}
				Pour la lisibilité et la bonne pratique du développement de l'application, il est nécessaire de suivre des règles établies au sein de 
				l'équipe de projet, appelées conventions. Ainsi, nous avons choisi d'écrire le code en anglais uniquement, mis à part pour les commentaires 
				utiles aux développeurs préférant le français. De même, au moins une ligne de commentaire est requise avant chaque déclaration de classe ou 
				de fonction, afin d'en expliquer brièvement son fonctionnement (sauf dans le cas de méthodes simples avec des noms explicites).\\
				Voici un tableau récapitulatif des conventions de nommages pour les noms de variables, classes et méthodes :
				\begin{table}[H]
					\begin{small}
						\hspace{1,5cm}
						\begin{tabular}{| c | c |}
							\hline
							\textbf{Type de variable} & \textbf{Format du nom}\\
							\hline
							Classe & Majuscule suivit de minuscules\\
							\hline
							Méthode & Minuscules (pour les mots composés,\\
							et & chaque mots suivant est\\
							Fonction & une majuscule suivit de minuscules)\\
							\hline
							Attribut de classe & Précédé par m\_\\
							\hline
							Variable globale & Précédé par g\_\\
							\hline
							Variable statique & Précédé par s\_\\
							\hline
						\end{tabular}
					\end{small}
					\label{tab:nommage}
					\caption{Conventions de nommage}
				\end{table}

			\subsection{Gestion du code source}
				Afin de faciliter le travail collaboratif, nous utilisons un dépôt utilisant le gestionnaire de version GIT, hébergé sur le site :
				\begin{center}
					\url{https://github.com/slvrgauthier/OpenSculpt}
					\label{url:github}
				\end{center}
				Sur ce dépôt sont présents tous les fichiers sources nécessaires au développement du programme ainsi que les documentations au format 
				\LaTeX, ODT et PDF (même si aucun fichier binaire ne devrait être présent, il est plus pratique de récupérer directement un tel fichier 
				que de le compiler soit-même). De plus, y sont stockées toutes les données utilisées par le programme telles que les images et autres 
				ressources. Seuls les fichiers temporaires, exécutables et fichiers de sauvegarde ne sont pas stockés.

%==========================================================================================================================================================
	\chapter{Réalisation}
		Au terme du temps imparti pour réaliser ce projet, nous pouvons dire que nous avons réalisé la plupart de nos objectifs initiaux. Ainsi, nous avons 
		abouti à un programme plus ou moins complet, comportant nombre de fonctionnalités. Ce chapitre est une démonstration du résultat final de notre 
		travail.
		
		\section{L'interface}
			Au niveau de l'interface, nous avons réussi à la développer selon trois critères majeurs : un aspect convivial, une ergonomie correcte et une 
			modularité rendant possible la personnalisation. Pour cela, les boutons les plus utilisés ont été placés le plus proche possible de la zone de 
			travail. De même, tous les panels contenant ces boutons, rangés logiquement par catégorie, sont mobiles, ce qui permet à l'utilisateur de les 
			interchanger voir de les "sortir" en tant que nouvelle fenêtre. Pour plus de détails, veuillez vous référer à la partie 
			\textbf{Manuel utilisateur}, page \pageref{man-user}, détaillant tous les éléments contenus dans celle-ci.
			
		\section{Les maillages prédéfinis}
			Nous avons implémenté, comme prévu, cinq maillages prédéfinis (cf page \pageref{model-cdc}). Chacun de ces maillages est basé sur une formule 
			géométrique, et créé face par face grâce aux fonctions de notre API (cf page \pageref{api-dev}). Voici des images montrant ces maillages à 
			leur création (respectivement cube, sphère, cylindre, cône et tore), avec pour chacun une présentation de l'objet plein et en fils de fer.
			\begin{figure}[H]
				\hspace{-2cm} \includegraphics[scale=0.27]{img/cube.png}
				\caption{Aperçu d'un cube}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/sphere.png}
				\caption{Aperçu d'une sphère}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/cylinder.png}
				\caption{Aperçu d'un cylindre}
			\end{figure}
			\begin{figure}[H]
				\hspace{-2cm} \includegraphics[scale=0.27]{img/cone.png}
				\caption{Aperçu d'un cône}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/torus.png}
				\caption{Aperçu d'un tore}
			\end{figure}
			Il est possible d'ajouter de nouveaux maillages prédéfinis, pour cela, référez-vous à la partie \textbf{Manuel développeur}, page 
			\pageref{man-dev}.
			
		\section{Les outils}
			Nous avons implémentés tous les outils prévus dans le cahier des charges (cf page \pageref{tool-cdc}). Ainsi, nous avons différentes catégories 
			d'outils, ceux déplaçant la caméra, ceux déplaçant les objets et les outils de sculpture. Voici des images montrant les résultats de 
			l'utilisation de chacun de ces derniers sur le maillage d'un cube. Chaque image contient sur la face gauche de l'objet l'utilisation normale de 
			l'outil et sur la droite l'utilisation de celui-ci en maintenant la touche "Shift" enfoncée.
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/add.png}
				\caption{Aperçu d'un ajout de matière}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/smooth.png}
				\caption{Aperçu d'un lissage}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/move.png}
				\caption{Aperçu d'un déplacement de matière}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/inflate.png}
				\caption{Aperçu d'un gonflement de matière}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/pinch.png}
				\caption{Aperçu d'un pincement de matière}
			\end{figure}
		
		\section{Les algorithmes}
			Nous avons ici deux types d'algorithmes : subdivision et décimation. Pour chacun d'entre eux, il existe deux méthodes utilisées (cf page 
			\pageref{processing-dev}), une pour l'algorithme appliqué sur l'objet dans son intégralité et une appliquée sur l'objet dans la zone d'action de 
			l'outil. Voici donc des images présentant les résultats de ces algorithmes :
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/g-sub.png}
				\caption{Aperçu d'une subdivision globale}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/l-sub.png}
				\caption{Aperçu d'une subdivision locale}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/g-dec.png}
				\caption{Aperçu d'une décimation globale}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/l-dec.png}
				\caption{Aperçu d'une décimation locale}
			\end{figure}
			
		\section{Sculptures}
			Voici quelques sculptures que nous avons réalisées avec notre logiciel. Pour les créer, nous avons utilisé plus ou moins tous les outils mis à 
			disposition.
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/result1.png}
				\caption{Sculpture d'un ...}
			\end{figure}
			\begin{figure}[H]
				\vspace{-0,5cm} \hspace{-2cm} \includegraphics[scale=0.27]{img/result2.png}
				\caption{Sculpture d'un ...}
			\end{figure}

%==========================================================================================================================================================
	\chapter{Manuel}
		
		\section{Utilisateur}

			\label{man-user}
			L'interface se décompose en quatre parties. Un panel à droite permet d'agir sur les objets de la scène : une liste des objets présents permet de 
			sélectionner l'objet sur lequel travailler, ainsi que de supprimer ou renommer celui-ci. Le panel droit contient également une boîte de dialogue 
			permettant de paramétrer nos objets (notamment à leur création). Une barre d'outils, dans la partie supérieure de la fenêtre, permet d'agir 
			sur la scène (déplacement de caméra, ajout d'objets...etc) ou l'objet courant (subdivision ou décimation). Un panel dans la partie gauche permet 
			de sélectionner un outil de sculpture, ainsi que de paramétrer notre Brush. Enfin, une sous-fenêtre au centre permet le rendu OpenGL de la scène.
			\\Voici un aperçu de notre interface, voulue ergonomique et dynamique (tous les panels sont mobiles) :
			\begin{figure}[H]
				\begin{center}
					\includegraphics[scale=0.27]{img/interface.png}
					\label{fig:interface}
					\caption{Aperçu de l'interface graphique}
				\end{center}
			\end{figure}
			Via cette interface, nous pouvons créer une scène comportant plusieurs objets. Tout d'abord, pour ajouter un objet à la scène, deux choix 
			s'offrent à nous :
			\begin{itemize}
				\item Soit à partir du menu : "Fichier" puis  "Nouvel objet".
				\item Soit en cliquant directement sur l'icône de l'objet voulu, présent dans la barre d'outils.
			\end{itemize}
			Une fois l'objet créé (au centre de la scène), la boîte de dialogue permettant de le paramétrer apparaît dans le panel droit :
			\begin{itemize}
				\item Dimensions géométriques (largeur, hauteur, profondeur ou rayon)
				\item Niveau de discrétisation (cf partie \textbf{Développement} page \pageref{mesh-dev})
				\item Nom de l'objet
			\end{itemize}
			L'objet se régénère en temps réel à chaque modification de paramètre (excepté le nom). Une fois l'objet validé, celui-ci apparaît dans la liste 
			située dans le panel droit. Nous remarquons que la figure sélectionnée est de couleur orange et que son nom dans la liste est surligné. Il est 
			donc possible de passer d'un objet à un autre en cliquant sur le nom de l'objet souhaité. De plus il est aussi possible d'accéder à certains 
			attributs d'un objet en effectuant un double clic ou un clic droit sur son nom. Nous avons alors la possibilité de modifier son nom ou de le 
			supprimer.\\\\ 
			Maintenant que nous avons créé un objet, nous allons pouvoir intéragir sur celui-ci ainsi que sur la scène à laquelle il appartient (par 
			utilisation de la souris : déplacement du curseur en maintenant le clic gauche enfoncé). Pour cela, nous pouvons utiliser la barre d'outils de 
			la partie supérieure de la fenêtre. Celle-ci est composée de plusieurs boutons auxquels sont associés des raccourcis clavier (représentés ici 
			entre parenthèses et guillemets).\\
			Tout d'abord, les boutons à gauche permettent d'agir sur la  scène. En effet nous avons (de gauche à droite) : 
			\begin{itemize}
				\item Désélectionner les boutons sélectionnés ("Esc").
				\item Déplacer la scène ("Alt+M") : déplace la scène dans la direction de la souris.
				\item Tourner la scène ("Alt+R") : tourne la scène dans la direction de la souris. Le clic droit permet par défaut cette fonctionnalité sans 
				la sélectionner.
				\item Zoomer ou dézoomer dans la scène ("Alt+S") : avance la caméra dans la scène selon la hauteur du déplacement de la souris (vers le haut 
				pour avancer, vers le bas pour reculer). La molette permet par défaut cette fonctionnalité sans la sélectionner.
			\end{itemize}
			Puis, les boutons au centre permettent d'annuler ("Ctrl+Z") ou refaire ("Ctrl+Y") une action et de subdiviser ("Ctrl+S") ou décimer ("Ctrl+D") 
			l'objet actif dans son intégralité.
			Enfin, nous avons les boutons permettant de créer un objet prédéfini (de gauche à droite) :
			\begin{itemize}
				\item Cube ("Ctrl+1")
				\item Sphère ("Ctrl+2")
				\item Cylindre ("Ctrl+3")
				\item Cône ("Ctrl+4")
				\item Tore ("Ctrl+5")
			\end{itemize}
			Nous pouvons manipuler les objets créés ainsi que leur appliquer des transformations. Pour cela, le panel de gauche nous permet de choisir un 
			outil de sculpture ou de manipulation globale de l'objet, ceux-ci ne modifiant que l'objet actif (en orange).\\
			Tout d'abord, nous avons les boutons situés en bas du panel, correspondant aux manipulations globales :
			\begin{itemize}
				\item Déplacer l'objet dans la scène ("Shift+M") : déplace l'objet dans la direction de la souris.
				\item Tourner l'objet ("Shift+R") : tourne l'objet dans la direction de la souris.
				\item Mettre à l'échelle l'objet ("Shift+S") : met à l'échelle l'objet selon la hauteur du déplacement de la souris (vers le haut pour 
				agrandir, vers le bas pour réduire).
			\end{itemize}
			Puis, nous avons les boutons en haut du panel, correspondant aux outils de sculpture :
			\begin{itemize}
				\item  Ajouter de la matière à l'objet ("A").
				\item  Lisser la surface de l'objet ("S"). 
				\item  Déplacer les polygones de l'objet ("M"). 
				\item  Faire gonfler la surface de l'objet ("I"). 
				\item  Pincer la surface de l'objet ("P").
			\end{itemize}
			Tous ces outils ont un rayon d'action appelé Brush, représenté par un cercle vert à l'écran. Il n'agissent donc uniquement sous le curseur, dans 
			une zone circulaire paramétrable (cf ci-dessous).\\
			Enfin, au centre, plusieurs paramètres réglables agissent sur notre objet : 
			\begin{itemize}
				\item Subdivision locale automatique : subdivise l'objet uniquement dans la zone d'action. Peut être cumulable avec un outil.
				\item Décimation locale automatique : décime l'objet uniquement dans la zone d'action. Peut être cumulable avec un outil.
				\item Modifier le brush (taille de la zone d'action et force d'attraction de l'outil).
			\end{itemize}
			Il est aussi possible d'agir grâce aux menus. Par exemple, le menu "Edition" permet de subdiviser, décimer ou lisser notre objet.\\
			De plus, nous pouvons changer les options de rendu via l'onglet "Affichage". En effet, il est possible de réinitialiser la vue de la 
			sous-fenêtre OpenGL ou d'activer ou désactiver le "mode fils de fer" (les raccourcis "F" et "W" permettent de passer du mode fils de fer 
			au mode plein).
			\begin{figure}[H]
				\begin{center}
					\includegraphics[scale=0.8]{img/wire-fill.png}
					\label{fig:wire-fill}
					\caption{Utilisation des raccourcis "W" et "F"}
				\end{center}
			\end{figure}
			Enfin, il est possible à tout moment de créer un nouveau projet ou enregistrer celui en cours grâce au menu "Fichier".

		\section{Développeur}
			\label{man-dev}
			Toute personne avec des bases de programmation peut étendre les fonctionnalités de celle-ci grâce à notre API. Les seuls prérequis sont 
			d'installer QtCreator et d'avoir les librairies Glut pour OpenGL. Pour le système d'exploitation windows, ces librairies sont inclues dans les 
			sources. Voir la note d'installation Windows.
			
			\subsection{Ajout d'un maillage modèle}
				Il est possible d'ajouter un maillage modèle afin d'enrichir les objets de base proposés à l'utilisateur.\\
				Pour cela, il est nécessaire d'ajouter plusieurs choses :
				\begin{itemize}
					\item Une fonction de génération du maillage dans la classe \textbf{Mesh}
					\item Un bouton ou une entrée de menu pour créer le modèle dans l'interface
					\item Des widgets (s'ils n'existent pas encore) pour les paramètres de génération
					\item Une fonction de mise à jour du maillage en temps réel
				\end{itemize}
				
				\subsubsection{Fonction de génération}
					Il est nécessaire d'ajouter cette fonction dans la classe \textbf{Mesh}. Nous conseillons, pour la clarté, de placer sa déclaration dans 
					"Mesh.h", sous les méthodes existantes de type :
					\begin{verbatim}
						void makeCube(float width, float height, float depth, int discretization);
					\end{verbatim}
					Toujours pour la facilité d'appréhension du code, nous conseillons de créer un nouveau fichier "make\textit{Polygon}.cpp" contenant la 
					définition de la fonction :
					\begin{verbatim}
						#include "Mesh.h"

						void Mesh::makeCube(float width, float height, float depth, int discretization) {
						    this->clear();
							
						    ...
							
						    this->TEST();
						}
					\end{verbatim}
					Il faut donc absolument inclure "Mesh.h", et surtout ne pas oublier d'utiliser la fonction clear(), qui permet de régénérer le maillage à
					chaque changement de paramètre. Une fonction TEST() est également disponible pour vérifier l'intégrité du maillage (à utiliser à la fin 
					de la fonction make\textit{Polygon}). Dans le corps de cette méthode, il est conseillé d'utiliser la méthode addFace (cf page 
					\pageref{mesh-dev}) pour chaque facette du maillage. Vous pouvez bien sûr prendre exemple des fonctions déjà implémentées.
					
				\subsubsection{Bouton, menu et widgets}
					Pour que l'utilisateur s'y retrouve facilement (mais ce n'est pas obligatoire si l'on ne souhaite qu'un raccourci clavier par exemple), 
					il est conseillé d'ajouter un bouton (via QtDesigner) dans le fichier "mainWindow.ui", formulaire de QtDesigner. Il suffit de recopier 
					les valeurs des boutons déjà présents, en ne changeant que le nom et l'icône de celui-ci. Ces boutons se situent à droite de la barre 
					d'outils, dans la partie supérieure de la fenêtre. De même pour l'entrée de menu ("Fichier" - "Nouvel Objet"). Il faut ensuite ajouter 
					les fonctions adéquates dans les fichiers "mainWindow.h" et "mainWindow.cpp", en prenant pour exemple celles déjà présentes du type :
					\begin{verbatim}
						void on_initCube_clicked(); // Bouton
						void on_actionNewCube_triggered(); // Menu
					\end{verbatim}
					La fonction \textit{on\_init()} doit être appelée au début de la première, afin de réinitialiser les paramètres de création et divers 
					autres détails. S'il est nécessaire d'ajouter des widgets, il faut prendre exemple sur ceux déjà présents (les \textit{doubleSpinBox} 
					de la boîte de dialogue du panel droit). Dans ce cas, il est également nécessaire d'ajouter des appels aux fonctions 
					\textit{setVisible()} et \textit{connect()} / \textit{disconnect()}, dans les méthodes de la classe "mainWindow" suivantes :
					\begin{verbatim}
						void on_init();
						void on_initVotrePolygone_clicked();
						void hideDialog();
					\end{verbatim}
					Pour le raccourci clavier, il suffit d'ajouter une entrée dans le switch de la méthode \textit{keyPressEvent(QKeyEvent *event)}.
					
				\subsubsection{Fonction de mise à jour}
					Il est nécessaire d'ajouter cette fonction dans la classe \textbf{MainWindow}. Nous conseillons de placer sa déclaration dans 
					"MainWindow.h", sous les méthodes existantes de type :
					\begin{verbatim}
						void updateCube();
					\end{verbatim}
					Il suffit ensuite de placer sa définition dans "MainWindow.cpp", selon l'exemple des méthodes déjà implémentées. Cette fonction est 
					obligatoire pour la génération (et régénération) du maillage.
				
			\subsection{Ajout d'un outil}
				Il est possible d'ajouter un outil afin d'enrichir les actions de sculpture proposées à l'utilisateur.\\
				Pour cela, il est nécessaire d'ajouter plusieurs choses :
				\begin{itemize}
					\item Un type d'outil dans l'énumération \textbf{TOOL}
					\item Une fonction d'action de l'outil dans la classe \textbf{MeshTool}
					\item Un bouton pour utiliser l'outil dans l'interface
					\item Une entrée dans la méthode "mouseMoveEvent" de la classe \textbf{GLWidget}
				\end{itemize}
				
				\subsubsection{Type d'outil et fonction d'action}
					Il est nécessaire d'ajouter le type de votre outil dans l'énumération "TOOL", déclarée dans le fichier "MeshTool.h". Pour la clarté, il 
					est conseillé de respecter la convention de nom expliquée en commentaire au dessus de l'énumération.\\
					Vous devez ensuite créer une méthode d'action. Nous vous conseillons de vous imprégner de la partie \textbf{Développement} (cf page 
					\pageref{tool-dev}) pour choisir les paramètres adéquats. Il suffit de la déclarer dans le fichier "MeshTool.h", sous les méthodes 
					existantes de type :
					\begin{verbatim}
						void gtmove(Mesh *mesh, QVector3D move);
					\end{verbatim}
					La déclaration se place dans le fichier "MeshTool.cpp". Il est encore une fois conseillé de bien comprendre la partie 
					\textbf{Développement} (cf page \pageref{tool-dev}) afin de créer l'effet désiré. De même, les fonctions déjà présentes peuvent servir 
					d'exemple. Les fonctions du fichier "functions.h" sont également très utiles.
					
				\subsubsection{Bouton}
					Pour que l'utilisateur s'y retrouve facilement (mais ce n'est pas obligatoire si l'on ne souhaite qu'un raccourci clavier par exemple), 
					il est conseillé d'ajouter un bouton (via QtDesigner) dans le fichier "mainWindow.ui", formulaire de QtDesigner. Il suffit de recopier 
					les valeurs des boutons déjà présents, en ne changeant que le nom et l'icône de celui-ci. Ces boutons se situent en haut du panel gauche.
					Il faut ensuite ajouter les fonctions adéquates dans les fichiers "mainWindow.h" et "mainWindow.cpp", en prenant pour exemple celles 
					déjà présentes du type :
					\begin{verbatim}
						void on_ltadd_clicked();
					\end{verbatim}
					Les fonctions \textit{disableTool()} et \textit{enableTool()} doivent être appelées, afin de ne sélectionner que l'outil voulu. Il est 
					également nécessaire d'ajouter un appel à la fonction \textit{setChecked()}, dans la méthode de la classe "mainWindow" suivante :
					\begin{verbatim}
						void disableTool();
					\end{verbatim}
					Pour le raccourci clavier, il suffit d'ajouter une entrée dans le switch de la méthode \textit{keyPressEvent(QKeyEvent *event)}.
					
				\subsubsection{Une réaction à l'évènement souris}
					La fonction "mouseMoveEvent" de la classe \textbf{GLWidget} s'occupe de gérer les outils à l'aide d'un switch. Vous devez donc ajouter 
					une entrée dans cette fonction afin de pouvoir utiliser votre outil. Seul le fichier "GLWidget.cpp" est utile ici :
					\begin{verbatim}
						void GLWidget::mouseMoveEvent(QMouseEvent *event) {
						    ...
						    switch(activeTool) {
						        case GTSCALE:
						            m_tool.gtscale(m_manager.getMesh(activeMesh), QVector3D(0, dy, 0));
						            break;
						    ...
						    }
						    ...
						}
					\end{verbatim}
					Nous vous conseillons de vous imprégner de la partie \textbf{Développement} (cf page \pageref{tool-dev}) pour 
					choisir les paramètres adéquats.
				
			\subsection{Pour aller plus loin...}
				Si un développeur souhaite modifier plus profondément l'application, il faut pour cela se référer à la partie \textbf{Développement} (cf 
				page \pageref{dev}), notamment les explications détaillant l'\textbf{API} (cf page \pageref{api-dev}).

%==========================================================================================================================================================
	\chapter{Développement}
		\label{dev}
		Ce chapitre est une sorte de carnet de bord. Il détaille tout ce qui concerne le développement de l'application.
		
		\section{API}
			\label{api-dev}
			Le principe d'une API est de fournir au développeur une surcouche permettant d'encapsuler les calculs et représentations internes à l'intérieur 
			d'un certain nombre de méthodes. Ces méthodes seront par la suite utilisables par le développeur afin de faciliter l'implémentation. Un 
			diagramme de classes est disponible en annexe (cf page \pageref{fig:diagClass}).
			
			\subsection{La structure interne}
				Nous avons conçu trois structures C++, représentant respectivement les demi-arêtes, les points et les faces. Ces trois structures utilisées 
				ensemble définissent la représentation des maillages par demi-arêtes :
				\begin{verbatim}
					typedef struct HalfEdge {
					    Vertex* vertex;
					    Face* face;
					    HalfEdge* next;
					    HalfEdge* opposite;
					    HalfEdge* previous;
					} HalfEdge;

					typedef struct Vertex {
					    QVector3D coords;
					    HalfEdge* outgoing;
					    int index;
					} Vertex;

					typedef struct Face {
					    HalfEdge* edge;
					} Face;
				\end{verbatim}
				Cette structure est certes relativement gourmande en stockage, mais très performante pour tous les algorithmes de transformations basés sur 
				le voisinage. Nous utilisons ici le voisinage non seulement pour le rendu, mais également dans chaque outil de sculpture et chaque fonction 
				telle que la subdivision. Nous avons d'ailleurs ajouté un entier dans la structure des points afin d'obtenir des accès immédiats lors du 
				rendu.\\
				\\
				Pour utiliser cette structure tout en séparant bien les types d'intéraction, nous avons créé un certain nombre de classes, dont chacune a un 
				rôle spécifique :
				\begin{itemize}
					\item \textbf{Mesh :} contient le maillage et toutes les méthodes de création de celui-ci (cf page \pageref{mesh-dev}).
					\item \textbf{MeshRenderer :} contient des buffer objects permettant le rendu d'un maillage (cf page \pageref{renderer-dev}).
					\item \textbf{MeshProcessing :} contient des méthodes statiques de modification de maillage (cf page \pageref{processing-dev}).
					\item \textbf{MeshTool :} contient les méthodes outils permettant la sculpture de l'objet (cf page \pageref{tool-dev}).
					\item \textbf{MeshManager :} contient et gère l'ensemble des objets de la scène (cf page \pageref{manager-dev}).
				\end{itemize}
				Toutes ces classes sont ensuite utilisées au sein de l'interface, notamment dans le widget OpenGL.
				
			\subsection{Les méthodes de la classe Mesh}
				\label{mesh-dev}
				\subsubsection{Génération des modèles prédéfinis}
					Comme expliqué précédemment (cf page \pageref{model-cdc}), nous avons plusieurs maillages prédéfinis. Pour chacun d'entre eux, 
					il existe une unique méthode, dans la classe Mesh, permettant de le générer :
					\begin{verbatim}
						void makeCone(float height, float radiusUp, float radiusDown, int discretization);
						void makeCube(float width, float height, float depth, int discretization);
						void makeCylinder(float height, float radius, int discretization);
						void makeSphere(float radius, int discretization);
						void makeTorus(float radiusH, float radiusV, int discretization);
					\end{verbatim}
					Chaque maillage prédéfinis comporte des paramètres géométriques, (par exemple largeur, hauteur et profondeur pour le cube ou rayon pour 
					la sphère) et un paramètre définissant le pas de discrétisation. Celui-ci permet de donner une résolution de base à l'objet, afin de 
					l'affiner selon la formule géométrique de celui-ci (par exemple, les bords d'un cylindre seront plus lisses).
					
				\subsubsection{Ajout d'une face}
					Il est possible de créer une face d'un maillage grâce à la fonction suivante :
					\begin{verbatim}
						bool addFace(QVector<QVector3D> vertices);
					\end{verbatim}
					En entrée, la méthode prend une liste de points, supposés ordonnés dans le sens direct. Ensuite, la méthode détecte les points déjà 
					existants et crée les autres. Enfin, la face est créée sous forme d'un TRIANGLE\_FAN (éventail), dont la base est le premier point 
					de la liste. Il est alors possible de compléter l'éventail par ajout d'une copie du second point à la fin de la liste.\\
					Un booléen est renvoyé pour attester du bon déroulement de celle-ci.
					
				\subsubsection{Découpage d'une arête}
					Il est possible de couper une arête en deux parts égales avec cette méthode :
					\begin{verbatim}
						bool cutEdge(QVector3D vertex1, QVector3D vertex2);
					\end{verbatim}
					Si l'arête joignant les deux points passés en paramètres existe, alors la méthode crée un point intermédiaire (au milieu de l'arête) et
					reforme les deux arêtes. Pour garder une certaine intégrité au sein du maillage, ce point intermédiaire est relié au troisième sommet 
					de chacun des deux triangles séparés par l'arête initiale.\\
					Un booléen est renvoyé pour attester du bon déroulement de celle-ci.
					\begin{figure}[H]
						\begin{center}
							\includegraphics[scale=0.55]{img/cutEdge.png}
							\caption{Principe de la méthode cutEdge}
						\end{center}
					\end{figure}
					
				\subsubsection{Fusion de deux arêtes}
					Il est possible de fusionner deux arêtes en une seule grâce à la fonction :
					\begin{verbatim}
						bool mergeEdge(QVector3D vertex1, QVector3D vertex2, QVector3D vertex3);
					\end{verbatim}
					S'il existe une arête entre "vertex1" et "vertex2", ainsi qu'une autre entre "vertex2" et "vertex3", alors la fonction fusionne ces deux 
					arêtes. Le principe de ce processus est de ramener un éventail de son centre vers une de ses extrémités. Donc, toutes les arêtes de 
					l'éventail de centre "vertex2" se redirigeront vers "vertex1". Il est conseillé d'utiliser cette fonction avec parcimonie, notamment en 
					vérifiant les angles entre les arêtes, car aucune vérification de recoupement de faces n'est effectué.
					\begin{figure}[H]
						\begin{center}
							\includegraphics[scale=0.55]{img/mergeEdge.png}
							\caption{Principe de la méthode mergeEdge}
						\end{center}
					\end{figure}
					
				\subsubsection{Récupération de points}
					Il est possible de récupérer une liste de points dans une certaine zone avec :
					\begin{verbatim}
						QVector<QVector3D> getVertices(QVector3D position, float areaSize);
					\end{verbatim}
					Le but de cette fonction est de renvoyer tous les points présents dans la zone de centre "position" et de rayon "areaSize". Pour cela, 
					un parcours récursif des voisins de la face contenant le centre, couplé avec des tests de distance point à point, renvoie tous les 
					points des faces voisines tant que la distance au centre reste inférieure au rayon. Si le rayon est égal à zéro, la fonction renvoie 
					uniquement les trois points de la face contenant le centre de la zone.\\ 
					Remarque : la liste de points renvoyée contient aussi "position".
					
				\subsubsection{Récupération de voisinage}
					Il est possible de récupérer une liste de points voisins d'un certain point avec :
					\begin{verbatim}
						QVector<QVector3D> getNeighbours(QVector3D vertex, int degree);
					\end{verbatim}
					Si le point passé en paramètre existe, alors la fonction renvoie, grâce à un parcours récursif basé sur les adjacences de faces, la 
					liste des points voisins de celui-ci. Le degré de voisinage permet d'obtenir des voisins plus éloignés, ce paramètre définissant le 
					nombre de récursions à effectuer lors du parcours.
					
				\subsubsection{Récupération de normale de surface}
					Il est possible de récupérer la normale à la surface de l'objet grâce à la méthode :
					\begin{verbatim}
						QVector3D getNormal(QVector3D position);
					\end{verbatim}
					Cette méthode détecte la face contenant le point passé en paramètre, et renvoie la normale au plan contenant cette face. Si aucune face 
					n'est détectée comme contenant ce point, le vecteur renvoyé sera la direction entre le centre de l'objet et le point "position", afin 
					d'éviter les scintillements du pinceau ou autres petits décalages du curseur pouvant créer des incohérences.
					
				\subsubsection{Translation de points}
					Il est possible d'effectuer une translation sur un ou plusieurs points à l'aide des fonctions :
					\begin{verbatim}
						void moveVertex(QVector3D vertex, QVector3D move);
						void moveVertex(int index, QVector3D move);
						void moveVertices(QVector<QVector3D> vertices, QVector3D move);
					\end{verbatim}
					Ces trois fonctions permettent au développeur d'effectuer des translations sur un ou plusieurs points, selon un vecteur passé en 
					paramètres ("move").
					
				\subsubsection{Les accesseurs}
					La classe Mesh contient également certains accesseurs utiles :
					\begin{verbatim}
						QVector3D getCenter() const;
						void setCenter(QVector3D center);

						QVector3D getCoords(int index) const;
						void setCoords(QVector3D vertex, QVector3D coord);
						void setCoords(int index, QVector3D coord);

						int getEdgeCount() const;
						int getVertexCount() const;
						int getFaceCount() const;
					\end{verbatim}
					Avec ces accesseurs, nous pouvons récupérer ou déplacer des points du maillage directement (y compris le centre de l'objet), ainsi que 
					connaitre des informations utiles telles que le nombre total de points, demi-arêtes ou faces.
				
			\subsection{Les méthodes de la classe MeshRenderer}
				\label{renderer-dev}
				\subsubsection{Dessin de l'objet}
					On effectue le rendu OpenGL avec la méthode suivante :
					\begin{verbatim}
						void paintGL();
					\end{verbatim}
					Cette méthode transmet à la carte graphique (donc le GPU), les buffers nécessaires au rendu OpenGL de l'objet. Il existe trois buffers : 
					les points, les normales et les indices. Nous avons choisi de passer par un buffer d'indices afin d'améliorer les performances (un 
					entier pour chaque point de chaque triangle au lieu de répéter trois flottants pour chaque point et trois de plus pour chaque normale).
					
				\subsubsection{Synchronisation des buffers}
					Il est parfois nécessaire d'actualiser ou non les buffer objects :
					\begin{verbatim}
						void update();
					\end{verbatim}
					Cette fonction permet d'actualiser les buffers. En effet, avec les modifications sur les maillages rendues possibles, il est souvent 
					nécessaire de resynchroniser les buffers avec le maillage existant. Ce processus a été séparé du processus de rendu afin de permettre de 
					changer les options de rendus sans recalculer la synchronisation qui n'est nécessaire que si le maillage est modifié.
				
			\subsection{Les méthodes de la classe MeshProcessing}
				\label{processing-dev}
				\subsubsection{Subdivision}
					Nous avons mis en place deux types de subdivision :
					\begin{verbatim}
						static void subdivide(Mesh *mesh);
						static bool subdivideAuto(Mesh *mesh, float maxEdgeLength);
					\end{verbatim}
					Ces deux processus de subdivision permettent de raffiner le maillage dans son intégralité.\\
					La première subdivision crée, pour chaque face, un triangle à l'aide des milieux de chaque arête de celle-ci. Un schéma est disponible en 
					annexe (cf page \pageref{fig:subdivide}). Celle-ci étant intimement liée à la structure interne des maillages, il est nécessaire de la 
					redéfinir si l'on décide de changer cette structure.\\
					La seconde méthode est paramétrable. En effet, le paramètre "maxEdgeLength" permet de ne couper que les arêtes dépassant cette taille. 
					Un booléen atteste de la modification ou non du maillage. Le processus utilisé est celui de la méthode "cutEdge" de la classe 
					\textbf{Mesh} (cf page \pageref{mesh-dev}).
					
				\subsubsection{Décimation}
					Nous avons mis en place deux types de décimation :
					\begin{verbatim}
						static void decimate(Mesh *mesh);
						static bool decimateAuto(Mesh *mesh, float minEdgeLength);
					\end{verbatim}
					Ces deux processus de décimation permettent de simplifier le maillage dans son intégralité.\\
					La première décimation fusionne chaque ensemble de quatre faces (cf schéma de subdivision page \pageref{fig:subdivide}) en une seule, si 
					et seulement si ces faces ont des angles dièdres inférieurs à une certaine valeur (ici 22.5 degrés mais paramétrable dans l'avenir). Les 
					faces déjà visitées sont enregistrées pendant le processus afin de ne pas faire plusieurs passes en une seule fois.\\
					La seconde méthode est paramétrable. En effet, le paramètre "minEdgeLength" permet de ne fusionner que les arêtes plus courtes que cette 
					taille. Un booléen atteste de la modification ou non du maillage.\\
					Le processus utilisé pour les deux méthodes est celui de la méthode "mergeEdge" de la classe \textbf{Mesh} (cf page \pageref{mesh-dev}).
				
			\subsection{Les méthodes de la classe MeshTool}
				\label{tool-dev}
				\subsubsection{Les outils de sculpture}
					Comme expliqué précédemment (cf page \pageref{tool-cdc}), nous avons plusieurs outils de sculpture présents. Pour chacun d'entre eux, 
					il existe une unique méthode, dans la classe MeshTool, définissant son action :
					\begin{verbatim}
						void gtmove(Mesh *mesh, QVector3D move);
						void gtrotate(Mesh *mesh, QVector3D move);
						void gtscale(Mesh *mesh, QVector3D move);

						void ltadd(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
						void ltinflate(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
						void ltmove(Mesh *mesh, QPoint last_position, QVector3D move, float brushSize);
						void ltpinch(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
						void ltsmooth(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
					\end{verbatim}

					Pour chaque outil, les paramètres diffèrent légèrement. En effet, nous pouvons retrouver le maillage de l'objet sélectionné "mesh",  un 
					vecteur de déplacement "move" (dans le repère scène ou déplacement de souris), la position du curseur "last\_position", la taille de la 
					zone d'action "brushSize", la force de l'outil "strenght" (force d'attraction de la matière : plus la force est forte, plus la 
					modification par l'outil va être significative), ou encore des KeyboardModifiers afin d'augmenter les possibilités de nos outils. 
					Mais comment fonctionnent ces outils ?\\\\
					\textbf{Remarque :} un Brush, cité ci-dessous, correspond à la zone circulaire de centre "last\_position" (en réalité on utilise par la 
					suite le point d'impact du curseur sur l'objet, donc des coordonnées dans le repère scène) et de rayon "brushSize". Ce brush permet de 
					définir la zone d'action des outils.
					\begin{itemize}
						\item \textbf{GTMove :} Translation par le vecteur "move" de chacun des points de l'objet.
						\item \textbf{GTRotate :} Rotation selon les composantes du vecteur "move" de chacun des points de l'objet, en prenant comme origine 
						du repère de rotation le centre de celui-ci.
						\item \textbf{GTScale :} Homothétie de l'objet selon le déplacement en ordonnées du vecteur "move", en prenant comme origine le 
						centre de l'objet.
						\item \textbf{LTAdd :} Translation de tous les points contenus dans le Brush selon la normale à la face touchée par le curseur, 
						pondérée par le paramètre "strenght". La touche Shift inverse la normale et permet donc de creuser.
						\item \textbf{LTSmooth :} Translation de chaque point contenu dans le Brush dans la direction des coordonnées moyennes de ses 
						voisins immédiats, pondérée par "strenght". La touche Shift augmente la force d'un facteur 20.
						\item \textbf{LTMove :} Translation de tous les points contenus dans le Brush selon le vecteur "move" (défini dans le repère scène).
						\item \textbf{LTInflate :} Translation de chaque point contenu dans le brush selon un vecteur défini par la normale de surface et la 
						distance entre le point et le centre du Brush. Ce vecteur est une addition du vecteur normal et de la composante plane (sur le Brush)
						du vecteur allant du centre du Brush vers le point. Ce qui a pour effet de créer un gonflement de la matière, puisque les directions
						des translations forment une bulle. La touche Shift permet d'inverser la normale et donc de creuser.
						\item \textbf{LTPinch :} Translation de chaque point contenu dans le brush selon un vecteur défini par la normale de surface et la 
						distance entre le point et le centre du Brush. Ce vecteur est une soustraction entre le vecteur normal et la composante plane (sur le
						Brush) du vecteur allant du centre du Brush vers le point. Ce qui a pour effet de créer un pincement de la matière, puisque les 
						directions des translations forment l'inverse d'une bulle. La touche Shift permet d'inverser la normale et donc de creuser.
					\end{itemize}
					\textbf{Remarque :} Les outils LTSmooth, LTMove, LTInflate et LTPinch pondèrent leurs translations par un coefficient de distance entre 
					le point translaté et le centre du Brush, de sorte que le déplacement décroisse avec la distance.
					\begin{figure}[H]
						\begin{center}
							\includegraphics[scale=0.5]{img/tool-dev.png}
							\caption{Translations par les outils de sculpture}
						\end{center}
					\end{figure}
					
				\subsubsection{Les outils spéciaux}
					De nouveaux outils, nommés ici "spéciaux", ont été développés suite à la proposition de notre encadrant :
					\begin{verbatim}
						void subdivideAuto(Mesh *mesh, QPoint last_position, float brushSize);
						void decimateAuto(Mesh *mesh, QPoint last_position, float brushSize);
					\end{verbatim}
					Ces deux outils sont en fait une subdivision ou une décimation, mais uniquement locale. Nous pouvons les utiliser soit seul, soit 
					conjointement à un des outils de sculpture. Ce sont en fait des processus paramétrés, d'où le "Auto" rappelant les méthodes de la classe 
					\textbf{MeshProcessing} (cf page \pageref{processing-dev}). En réalité, le processus est similaire, sauf qu'ici le paramètre de longueur 
					d'arête est calculé grâce à une moyenne des longueurs d'arêtes contenues dans la zone d'action. Les fonctions utilisées sont également 
					"cutEdge" et "mergeEdge" de la classe \textbf{Mesh} (cf page \pageref{mesh-dev});
				
			\subsection{Les méthodes de la classe MeshManager}
				\label{manager-dev}
				\subsubsection{Dessin et synchronisation}
					On effectue le rendu OpenGL et la synchronisation des buffers à l'aide de ces fonctions :
					\begin{verbatim}
						void paintGL(int activeMesh);
						void updateMesh(int index);
						void updateLastMesh();
					\end{verbatim}
					Cette classe permet facilement de faire appel à tous les objets itérativement, et offre également quelques options. En effet, le 
					paramètre "activeMesh" permet le rendu du maillage actif d'une couleur différente des autres par exemple. De même, nous pouvons choisir 
					quel maillage nous avons besoin de mettre à jour.
					
				\subsubsection{Ajout et suppression}
					Puisque le MeshManager est un conteneur, il est possible d'ajouter ou de supprimer un ou plusieurs maillages :
					\begin{verbatim}
						void addMesh(Mesh *mesh);
						void removeMesh(Mesh *mesh);
						void clear();
					\end{verbatim}
					Ces fonctions d'ajout et de suppression permettent de ne pas gérer nous même les suppressions d'objet de la mémoire, puisque le manager 
					s'en occupe. Ainsi, la programmation s'en retrouve moins compliquée.
		
		\section{Interface}
			
			\subsection{Diagramme de l'interface}
				Notre interface contient un certains nombre de widgets divers et variés.
				\begin{figure}
					\hspace{-4cm}\includegraphics[scale=0.50]{img/diagramInterface.png}
					\label{fig:interface}
					\caption{Diagramme des widgets de l'interface graphique}
				\end{figure}
				Comme nous pouvons le voir, l'ensemble des widgets est rassemblé dans la MainWindow. Nous avons donc : 
				\begin{itemize}
					\item Le MenuBar est composé de plusieurs widgets : 
					\begin{itemize}
						\item Le MenuNewObject : permet de créer un nouvel objet.
						\item Le MenuFile : permet d'accéder à différents paramètres tels que ouverture ou la création d'un projet.
						\item Le MenuEdition : permet d'accéder à différents paramètres agissant sur l'objet.
						\item Le MenuView : permet d'accéder à différents paramètres agissant sur la fenêtre ou le rendu.
						\item Le MenuHelp : permet d'accéder à différents paramètres aidant l'utilisateur.
					\end{itemize}
					\item Le CentralWidget : permet d'afficher la fenêtre OpenGL (le rendu donc).
					\item Le DockWidgetScene : permet d'interagir sur la scène via l'interface.
					\item Le DockWidgetObjet : permet d'interagir sur l'objet actif via l'interface.
					\item Le InitFigure : permet de paramètrer les objets lors de leur création (ou modification).
				\end{itemize}
				
%==========================================================================================================================================================
	\chapter{Post-Mortem}
		Cette section liste toutes les étapes de la conception que nous n'avons pas réalisées (selon notre ordre de priorités), ainsi que toutes les 
		améliorations auxquelles nous avons pensé lors de la phase de développement.
		
		\section{Fonctionnalités non implémentées}
			Nous avions, lors de la conception de ce projet, prévu nombre de fonctionnalités. Malheureusement, ce projet ayant une durée de 
			développement limitée à quatre semaines, nous n'avons pas pu toutes les mettre en place.\\
			Voici une liste non exhaustive de certaines fonctionnalités que nous voulions :
			\begin{itemize}
				\item Possibilité de créer et placer plusieurs lumières, ou déplacer l'existante, afin de créer une illumination personnalisée de notre 
				scène.
				\item Possibilité de créer ou utiliser différents matériaux ou shader pour nos objets.
				\item Possibilité de peindre nos objets avec différentes couleurs (un color-picker aurait pu être présent), ainsi que leur appliquer 
				une texture de notre choix.
				\item Implémenter un "mode miroir" pour la sculpture. Ce mode permettrait à l'utilisateur de sculpter l'objet symétriquement, en 
				n'agissant que sur un côté de celui-ci. Nous aurions voulu pouvoir implémenter une symétrie en abscisse, en ordonnées ou en profondeur, 
				ainsi qu'une symétrie centrale permettant facilement de modeler des cercles parfaits.
				\item Implémenter des outils d'union, différence et intersection d'objets entre eux.
				\item Permettre de passer d'une représentation surfacique à une représentation volumique et inversément.
				\item Permettre l'affichage d'une grille (deux ou trois dimensions), ainsi que les repères scène et objet.
				\item Les fonctions "undo()" et "redo()".
				\item La gestion des sauvegardes.
			\end{itemize}
			
		\section{Améliorations réalisables}
			Comme pour tout projet, la conception n'offre pas toujours une liste exhaustive des fonctionnalités futures, étant donné que nous pouvons 
			toujours améliorer notre programme selon les possibilités offertes par le développement de celui-ci. Ainsi, nous avons quelques suggestions 
			d'améliorations pour notre logiciel, dans le cadre d'une éventuelle reprise de son développement :
			\begin{itemize}
				\item Optimisation : beaucoup de nos algorithmes pourraient être améliorés, notamment les comparaisons de points de par la surcouche de 
				l'API qui se déroulent en O(n) et pourraient l'être en O(1) avec par exemple des fonctions de hachage. D'autres, plus coûteux, 
				nécessiteraient une recherche approfondie pour améliorer les performances.
				\item Contenu : notre logiciel ne propose que cinq outils et cinq maillages prédéfinis, un aspect qui pourrait facilement être enrichi 
				avec plus de temps.
				\item Maillage : il serait utile de mettre en place bon nombre de fonctions de vérification de maillage, notamment les recoupements de 
				triangles.
				\item Autre : les fonctions de subdivision et décimation mériteraient sûrement d'être améliorées, notamment la décimation globale qui ne
				fait pas exactement l'inverse de la subdivision. De plus, les rotations ne s'effectuent actuellement que par rapport au déplacement souris,
				et ne prennent donc pas en compte l'angle de vue actuel.
			\end{itemize}

%==========================================================================================================================================================
	\chapter{Conclusion}
		Ce projet ne s'est pas déroulé exactement comme nous l'avions prévu. En effet, certaines difficultés nous ont fait perdre un temps considérable.\\
		\\
		La principale difficulté de ce sujet était de concevoir une API adaptée, et avec laquelle il serait facile de travailler. Comme nous pouvons le voir 
		dans le diagramme de Gantt final (cf page \pageref{fig:gantt}), la conception et l'implémentation de notre API se sont faites en trois étapes.\\\\
		La première consistait à créer un certain nombre de classes permettant un premier rendu d'un maillage, à travers l'interface de base.\\\\ La seconde,
		plus  complexe, avait pour but d'implémenter une structure de maillage interne, à savoir la structure par demi-arêtes. Cette étape a été relativement
		compliquée, puisque nous n'avions jamais utilisé cette structure, que nous devions l'adapter selon notre utilisation de celle-ci, et bien sûr, 
		concevoir un premier maillage à base de demi-arêtes afin de pouvoir avancer dans le développement du reste du programme. Le problème majeur que nous 
		avons rencontré à ce moment-là était le fait que toutes nos fonctions et nos maillages dépendaient directement de la structure. Il était alors très 
		difficile (du moins cela demandait beaucoup d'expertise) de concevoir les maillages et autres fonctions complexes.\\\\ C'est suite à une réunion avec
		nos encadrants que nous avons abouti à une première solution : concevoir une vraie API, avec une surcouche de fonctions faciles à appréhender. Pour 
		cela, nous avons dû reconcevoir entièrement nos classes, afin de séparer distinctement les rôles de celles-ci. Ainsi, nous avons abouti à quatre 
		classes (maillage, rendu, outils et algorithmes spécifiques tels que la subdivision par exemple). De même, nous avons implémenté un certain nombre de
		fonctions de "façade" permettant alors de cacher la structure interne et permettre de développer le contenu sans expertise spécifique à celle-ci.
		Cette étape a donc été le point clé du développement, puisque grâce à la nouvelle API, nous avons pu avancer facilement dans le projet avec une base 
		solide. De plus, une API permet de facilement paralléliser le travail au sein de l'équipe de projet.\\
		\\
		Ce projet nous a donc permis de nous améliorer sur le plan de l'organisation. En effet, savoir correctement concevoir une interface de programmation,
		prévoir les différentes utilisations possibles de celle-ci et adapter les classes en fonction d'elles permet de gagner un temps considérable lors de 
		la phase de développement. Ainsi, ce projet nous a prouvé qu'il ne faut jamais négliger la phase de conception, et qu'il ne faut pas non plus avoir 
		peur de changer, même entièrement, ce qui a déjà été développé si cela permet à terme une amélioration.\\
		\\
		Ce sujet a été pour nous une très bonne introduction pour le stage à venir, et malgré la quantité de travail que nous nous sommes imposée, nous nous 
		en sommes finalement bien sortis dans l'ensemble. De plus, les encadrants nous ont réellement aidés en nous proposant des pistes qui nous ont amenés 
		à réaliser nos objectifs.
		%TODO : image d'un résultat final (objet sculpté)
	
%==========================================================================================================================================================
	\appendix
	\chapter{}
		Dans cette partie sont placés les éléments trop volumineux pour être inclus directement dans le texte, tels que les images ou graphiques.\\
		
		\section{Diagramme de Gantt}
			Les diagrammes sont fournis page \pageref{fig:gantt}.
			
		\section{Comparatif de performances}
			Le graphique est situé page \pageref{fig:analyse}.
			
		\section{Diagramme de Classes}
			Le diagramme est fourni page \pageref{fig:diagClass}.
			
		\section{Schémas explicatifs}
			Les différents schémas explicatifs se trouvent page \pageref{fig:subdivide} à \pageref{fig:cube}.
			
		\section*{}
			\newpage
			\begin{figure}
				\vspace{-3,5cm} \hspace{-4,5cm} \includegraphics[scale=0.6]{img/Gantt1.png}
			\end{figure}
			
			\begin{figure}
				\hspace{-5,25cm} \includegraphics[scale=0.5]{img/Gantt2.png}
				\label{fig:gantt}
				\caption{Diagrammes de Gantt prédictif (en haut) et final (en bas)}
			\end{figure}
			
			\begin{figure}
				\begin{center}
					\includegraphics[scale=0.5]{img/AnalyseLangage1.png}
					\includegraphics[scale=0.5]{img/AnalyseLangage2.png} 
				\end{center}
				\label{fig:analyse}
				\caption{Comparaisons de performances de divers langages dans des cas donnés}
				Source : \url{http://attractivechaos.wordpress.com/2011/06/22/my-programming-language-benchmark-analyses/}
			\end{figure}
			
			\begin{figure}
					\hspace{-5cm}\includegraphics{img/diagClass.png}
				\label{fig:diagClass}
				\caption{Diagramme de classes de notre API}
			\end{figure}
			
			\begin{figure}
				\hspace{-3cm}\includegraphics[scale=0.5]{img/subdivide.png}
				\label{fig:subdivide}
				\caption{Schéma de subdivision globale}
			\end{figure}
			
			\begin{figure}
				\hspace{-4cm}\includegraphics[scale=0.5]{img/cube2.png}
				\label{fig:cube}
				\caption{Conception d'un cube avec la représentation par demi-arêtes}
			\end{figure}

\end{document}
