\documentclass[a4paper]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{enumitem}
\usepackage[babel=true]{csquotes}

\pagestyle{plain}

\title{
	\textbf{Rapport de projet}
	\bigskip
	\begin{center}
		\includegraphics[scale=0.25]{img/OpenSculpt.png}
	\end{center}
	\bigskip
}
\author{\emph{GAUTHIER Silvère}\\\emph{LAMEIRA Yannick}\\\emph{PELADAN Cécile}}
\date{\today}

\begin{document}
	\maketitle
	\newpage
	\tableofcontents

	\chapter{Remerciements}

		Un grand merci à Frédéric Boudon et Benjamin Gilles pour leur encadrement.
		Un remerciement particulier à Frédéric Boudon pour son idée d'outil de subdivision locale.

	\chapter{Introduction}
		
		\section{Sujet initial}
			L'objectif de ce projet est de créer un logiciel de sculpture 3D. L'utilisateur aurait à disposition un maillage déformable, qu'il pourrait 
			modeler avec différents outils tels que déplacement, ajout de matière ou lissage. L'interface devra permettre à l'utilisateur de facilement 
			créer un maillage initial, le visualiser et interagir avec lui à l'aide des différents outils de modelage. Initialement, les premières 
			fonctionnalités à implémenter seront la création d'une sphère ou d'un cube comme maillage de départ, la navigation dans l'espace 3D pour se 
			positionner autour du maillage, puis les outils de déformation cités ci-dessus. Une interface graphique contenant les boutons d'outils sera 
			définie pour que l'utilisateur puisse intuitivement appliquer les différentes opérations proposées.

			Les principales difficultés ici seront d'abord de gérer correctement l'interaction 3D de l'utilisateur avec le maillage via le curseur et la 
			fenêtre 2D. Ensuite viendra la mise en place d'une structure de données efficace et robuste de maillage avec l'implémentation des algorithmes 
			de subdivision et de raffinement.

			Si le temps le permet, d'autres outils et maillages de base pourront être implémentés, afin d'enrichir le logiciel. On pourra également 
			réfléchir à une manière d'importer et exporter les maillages sous différents formats tels que le OBJ ou le STL par exemple.

			Ce logiciel sera développé en C++ avec la bibliothèque OpenGL pour le rendu 3D et la bibliothèque Qt pour définir l'interface.

%==========================================================================================================================================================
	\chapter{Cahier des charges}
		Ce chapitre détaille la phase de conception du projet.
			
		\section{Mécanismes}
			Cette section détaille succintement les fonctionnalités de l'application.
			
			\subsection{Les Modèles}
				\label{model-cdc}
				Différents maillages prédéfinis, appelés ici modèles, seront mis à disposition de l'utilisateur.\\
				Nous en prévoyons actuellement cinq, paramétrables par l'utilisateur :
				\begin{itemize}
					\item \textbf{Cube :} défini par une largeur, une hauteur et une profondeur.
					\item \textbf{Sphère :} défini par un rayon.
					\item \textbf{Cylindre :} défini par une hauteur et un rayon.
					\item \textbf{Cône :} défini par une hauteur et un rayon.
					\item \textbf{Tore :} défini par un rayon horizontal et un rayon vertical.
				\end{itemize}
				Chaque modèle sera aussi paramétré par un pas de discrétisation.
				
			\subsection{Le Rendu}
				Le rendu s'effectuera dans une classe spécifique, et permet de synchroniser la structure interne des maillages avec les buffer objects. Il 
				existera également différentes options de rendu telles que l'affichage solide ou en fils de fer, les couleurs, les lumières...etc.

			\subsection{Les Outils de sculpture}
				\label{tool-cdc}
				Différents outils seront disponibles. Ils auront pour action de modifier le maillage dans la direction des normales de surface, et selon
				un schéma de modification propre à chaque outil. Nous avons défini deux catégories d'outils : modifications globales et locales des objets
				(une troisième est destinée au déplacement de la caméra dans la scène en trois dimensions).
				\newpage
				\begin{itemize}
					\item \textbf{Modifications Globales :}
					\begin{itemize}
						\item \textbf{GTMove :} Déplacement d'un objet dans le repère scène.
						\item \textbf{GTRotate :}Rotation d'un objet dans le repère scène.
						\item \textbf{GTScale :}Mise à l'échelle d'un objet dans le repère scène.
					\end{itemize}
					\item \textbf{Modifications Locales :}
					\begin{itemize}
						\item \textbf{LTAdd :}Ajout de matière à la surface de l'objet.
						\item \textbf{LTSmooth :}Lissage de la surface de l'objet.
						\item \textbf{LTMove :}Déplacement d'une partie des points de la surface de l'objet.
						\item \textbf{LTInflate :}Gonflement de la surface de l'objet.
						\item \textbf{LTPinch :}Pincement de la surface de l'objet.
					\end{itemize}
				\end{itemize}

			\subsection{Les Algorithmes de maillage}
				Les différents algorithmes de modification de maillages seront regroupés dans une classe statique spécifique. Y seront présentes les 
				fonctions de subdivision et de décimation globale, ainsi qu'une subdivision et une décimation automatique paramétrable avec une longueur 
				(maximale ou minimale) d'arête.

			\subsection{Interface}
				L'interface de l'application devra être ergonomique et proposer de nombreux raccourcis clavier afin de permettre à l'utilisateur de 
				travailler rapidement. Elle devra également être le plus intuitive possible, car un tel logiciel pourrait devenir très compliqué à 
				appréhender. Cela concernera tant les dispositions que les icônes qui devront suivre une certaine logique.

			\subsection{Les Options}
				% TODO : détailler brièvement les options de rendu, d'interface...etc
	
		\section{Structure du programme}
			Cette partie détaille succintement la structure globale du logiciel, ce qui couvre les aspects non maîtrisables par l'utilisateur.
			
			\subsection{L'API}
				L'application devra contenir une surcouche, ayant pour objectif de rendre notre logiciel facilement extensible par d'autres développeurs, 
				sans qu'ils aient besoin de connaître tous les détails de la structure interne de celui-ci.
				
				La structure interne des maillages retenue ici est la structure par demi-arêtes. Nous auront donc, pour chaque maillage, des listes de 
				points, faces et demi-arêtes.\\ Chaque point contiendra des coordonnées en trois dimensions, un indice de position dans la liste afin 
				d'améliorer la vitesse d'accès, ainsi qu'un pointeur vers une demi-arête sortante.\\ Chaque face contiendra un pointeur vers une demi-arête 
				intérieure, et éventuellement un vecteur normal.\\ Chaque demi-arête contiendra des pointeurs vers : une face, un point, les demi-arêtes 
				suivantes et précédentes au sein de la même face, et la demi-arête opposé.
				
				Plusieurs méthodes publiques devront être présentes, telles que "ajouter une face", "couper une arête en deux", "fusionner deux arêtes"... 
				et cacher la structure interne (n'agir qu'à l'aide de coordonnées par exemple). Cela permettra dans le futur, si besoin, de changer la 
				structure interne sans modifier le reste de l'application.
		
%==========================================================================================================================================================
	\chapter{Gestion du projet}
		Cette partie traite globalement de tout ce qui concerne l'organisation du projet, que ce soit au niveau de la conception, du développement, de 
		l'équipe ou encore de la gestion des fichiers.
		
		\section{Gestion de l'équipe}
			Tous les membres se connaissant et étant supposés être capable de travailler en équipe, nous n'avons fait aucune élection préalable de chef de 
			projet.\\ Mais le déroulement du projet nous a imposé ce choix, GAUTHIER Silvère assurera donc ce rôle, afin de garder une cohésion de groupe 
			et assurer la réalisation de nos objectifs.\\ Chaque membre peut tout de même participer activement au projet, autant lors de la conception que 
			du développement. Toutes les décisions seront prises suivant la majorité lors de votes.\\\\
			Pour ce qui est des réunions de projets, nous avons convenu avec nos tuteurs d'une réunion, allant d'environ trente minutes à une heure, toutes 
			les semaines, afin de mettre au point l'avancement du projet. En parallèle, tous les membres de notre équipe se retrouvent une fois par semaine 
			afin de discuter des points clés effectués ou à venir, donner lieu aux votes pour les prises de décisions, ou encore, lors de la phase de 
			développement, travailler en collaboration afin d'optimiser notre travail.\\\\
			Au niveau du travail collaboratif, nous avons mis en place un dépôt sur github (adresse à la page \pageref{url:github}), contenant tant la 
			documentation que les sources de notre programme. Par ailleurs, nous mettrons sur ce dépôt uniquement les fichiers sources et les images, mais 
			en aucun cas les fichiers temporaires ou les exécutables. Les seuls fichiers binaires disponibles seront les PDF de la documentation, pour un 
			soucis de facilité d'accès et de lecture.

		\section{Découpage en tâches}
			Afin de préparer le développement du programme, il était nécessaire de séparer les fonctionnalités les unes des autres. Nous avons abouti à ce 
			diagramme, qui résume notre choix de découpage :\\
			\begin{figure}[H]
				\begin{center}
					\includegraphics[scale=0.5]{img/DiagrammeDecoupageProjet.png}
				\end{center}
				\label{fig:decoupage}
				\caption{Diagramme des tâches du projet}
			\end{figure}

		\section{Assignation}
			Le projet étant découpé en un certain nombre de modules, il ne restait plus qu'à assigner chaque tâche à un ou plusieurs membres de l'équipe. 
			Nous nous sommes organisés comme ceci :
			\begin{itemize}[label=$\bullet$]
				\item \textbf{Conception, implémentation et vérifications de l'API} : GAUTHIER Silvère.
				\item \textbf{Mise en place de l'interface} : LAMEIRA Yannick.
				\item \textbf{Implémentation des maillages modèles} : PELADAN Cécile.
				\item \textbf{Conception et implémentation des outils} : GAUTHIER Silvère, LAMEIRA Yannick, PELADAN Cécile.
				\item \textbf{Tests et vérifications de l'application} : GAUTHIER Silvère, LAMEIRA Yannick, PELADAN Cécile.
			\end{itemize}
			Bien entendu, les membres pourront évidemment faire appel aux autres pour trouver une solution à un problème par exemple.\\
			Le détail complet des tâches et assignations se situe dans la section Gestion du temps, page \pageref{GestionTps}.

		\section{Gestion du temps}
			\label{GestionTps}
			Afin de clarifier notre gestion du temps, deux diagrammes de Gantt (prédictif et final) sont disponibles en annexe (cf page \pageref{fig:gantt}) 
			et dans la documentation de notre projet.\\

		\section{Choix technologiques}
			Afin de pouvoir développer correctement notre logiciel, il a fallu définir tout ce que nous allions utiliser en terme de langages et 
			bibliothèques selon notre logique de conception.
			
			\subsection{Langages de programmation}
				Pour des besoins de performances, nous avons comparé différents langages. Pour réduire le temps de recherche et de comparaison, nous nous 
				sommes appuyé sur des tests déjà effectués par d'autre.\\ Des tests de performances concernant un large panel de langages, comparés dans 
				quatre contextes différents, sont fournis en annexe, page \pageref{fig:analyse}.\\ Nous pouvons observer que globalement, le langage le plus 
				rapide est ici C++. L'utilisation de ce langage étant très fréquente dans les applications en temps réel, de part sa réputation d'un des 
				langages les plus performants, et tous les membres de notre équipe sachant l'utiliser, nous avons fait le choix de programmer le logiciel en 
				C++.\\

			\subsection{Bibliothèques}
				Pour la gestion graphique de l'interface et de l'affichage de l'objet, nous avons cherché une bibliothèque relativement simple d'utilisation 
				mais surtout performante afin de garder la fluidité gagnée avec le choix des langages de programmation.\\ Connaissant la bibliothèque 
				OpenGL, qui est bas niveau et performante dans les affichages deux et trois dimensions, nous nous sommes tournés vers une bibliothèque 
				utilisant OpenGL : Qt.\\

			\subsection{Représentation du maillage}
				Nous cherchons ici à comparer différentes techniques permettant de représenter un maillage, afin de choisir celle qui sera la plus adaptée à 
				nos opérations. Voici un tableau récapitulatif de cette étude comparative :
				\begin{table}[H]
					\begin{small}
						\hspace{-2,5cm}
						\begin{tabular}{| c | l | l |}
							\hline
							\textbf{Représentation} & \textbf{Avantages} & \textbf{Inconvénients}\\
							\hline
							 & - Hiérarchie des résolutions & - Visualisation surfacique difficile\\
							Octree ou KDTree & - Rendu volumique possible & - Coût de stockage excessif\\
							 & - Construction et parcours simples & - Recalculer à chaque modification\\
							\hline
							 & - Historique de construction & - Non unicité\\
							Arbre CSG & - Approche fonctionnelle & - Opérations complexes\\
							 &  & - Domaine insuffisant\\
							\hline
							G-maps & - Opérations de topologie simples & - Séparation topologie / plongement\\
							 & - Plongements multiples & \\
							\hline
							Liste de triangles & - Opérations simples & - Stockage non optimisé\\
							\hline
							Sommets partagés & - Opérations simples & \\
							 & - Stockage correct & \\
							\hline
							Bandes de triangles & - Stockage correct & - Chaque sommet est visité deux fois\\
							 &  & - Opérations de déplacement délicates\\
							\hline
							Structure par faces & - Chaque face pointe sur ses sommets & - Pas d'accès direct aux arêtes\\
							 & - Une face connaît les faces adjacentes & \\
							\hline
							Structure par demi-arêtes & - Parcours de maillage très pratiques & - Coût de stockage excessif\\
							\hline
							Vertex Array (VAO) & - Optimisé pour le rendu OpenGL & - Utilise le CPU et la RAM\\
							 & - Simple d'utilisation & \\
							\hline
							Vertex Buffer Object (VBO) & - Optimisé pour le rendu OpenGL & \\
							 & - Utilise le GPU et la VRAM & \\
							\hline
						\end{tabular}
					\end{small}
					\label{tab:maillage}
					\caption{Tableau comparatif de méthodes de représentation de maillage 3D}
				\end{table}
				L'étude comparative montre qu'il serait judicieux d'utiliser conjointement des Vertex Buffer Objects (VBOs) afin d'optimiser les 
				performances d'affichage et une classe personnalisée pour aisément gérer nos données par une surcouche de méthodes. La structure interne des 
				maillages sera donc une structure de type demi-arêtes, afin de faciliter les opérations de voisinage.
			
		\section{Gestion des fichiers}
			Nous avons beaucoup de fichiers à gérer dans ce projet, et nous devions établir des conventions ou des moyens afin de les gérer correctement.
			
			\subsection{Format des Fichiers}
				Le code étant écrit en C++, nous utiliserons des fichiers d'en-tête au format H et des fichiers de définition au format CPP.\\
				Toutes les images nécessaires au logiciel seront au format PNG afin de pouvoir utiliser la transparence et garder la pleine qualité d'image 
				(contrairement à JPEG qui perd de l'information à la compression).\\
			
				\subsubsection{Sauvegarde}
					Une façon judicieuse de sauvegarder nos données serait d'avoir un format spécial pour enregistrer un projet complet contenant une liste 
					d'objets, ainsi qu'une possibilité d'exportation de chaque objet ou scène dans un format connu tel que STL ou OBJ.
			
			\subsection{Commentaires}
				Si une méthode ou fonction (voir même un bloc) dépasse une certaine taille ou devient trop compliquée, un commentaire sera ajouté avant 
				celle-ci expliquant brièvement son processus :
				\begin{verbatim}
					/** Description :
					*** Entrée : ...
					*** Sortie : ...
					**/
				\end{verbatim}
				Quelque commentaires précieux pour le travail collaboratif seront également présents :
				\begin{table}[H]
					\begin{small}
						\hspace{-0,5cm}
						\begin{tabular}{| c | c |}
							\hline
							\textbf{Marqueur spécifique} & \textbf{Signification}\\
							\hline
							TODO & A mettre à la place du code d'une fonctionnalité à implémenter\\
							\hline
							RECODE & A mettre au dessus du bloc d'une fonctionnalité à refaire ou à optimiser\\
							\hline
							FIXME & A mettre au dessus du bloc d'une fonctionnalité contenant un bug\\
							\hline
						\end{tabular}
					\end{small}
					\label{tab:commentaire}
					\caption{Forme et usage des commentaires}
				\end{table}

			\subsection{Conventions de Nommage}
				Pour la lisibilité et la bonne pratique du développement de l'application, il est nécessaire de suivre des règles établies au sein de 
				l'équipe de projet, appelées conventions. Ainsi, nous avons choisi d'écrire le code en anglais uniquement, mis à part pour les commentaires 
				utiles aux développeurs préférant le français. De même, au moins une ligne de commentaire est requise avant chaque déclaration de classe ou 
				de fonction, afin d'en expliquer brièvement son fonctionnement (sauf dans le cas de méthodes simples avec des noms explicites).\\
				Voici un tableau récapitulatif des conventions de nommages pour les noms de variables, classes et méthodes :
				\begin{table}[H]
					\begin{small}
						\hspace{1,5cm}
						\begin{tabular}{| c | c |}
							\hline
							\textbf{Type de variable} & \textbf{Format du nom}\\
							\hline
							Classe & Majuscule suivit de minuscules\\
							\hline
							Méthode & Minuscules (pour les mots composés,\\
							et & chaque mots suivant est\\
							Fonction & une majuscule suivit de minuscules)\\
							\hline
							Attribut de classe & Précédé par m\_\\
							\hline
							Variable globale & Précédé par g\_\\
							\hline
							Variable statique & Précédé par s\_\\
							\hline
						\end{tabular}
					\end{small}
					\label{tab:nommage}
					\caption{Conventions de nommage}
				\end{table}

			\subsection{Gestion du code source}
				Afin de faciliter le travail collaboratif, nous utilisons un dépôt utilisant le gestionnaire de version GIT, hébergé sur le site :
				\begin{center}
					\url{https://github.com/slvrgauthier/OpenSculpt}
					\label{url:github}
				\end{center}
				Sur ce dépôt seront présents tous les fichiers sources nécessaires au développement du programme ainsi que les documentations au format 
				\LaTeX, ODT et PDF (même si aucun fichier binaire ne devrait être présent, il est plus pratique de récupérer directement un tel fichier 
				que de le compiler soit-même). De plus, y seront stockées toutes les données utilisées par le programme telles que les images et autres 
				ressources. Seuls les fichiers temporaires, exécutables et fichiers de sauvegarde ne seront pas stockés.

%==========================================================================================================================================================
	\chapter{Développement}
		\label{dev}
		Ce chapitre est une sorte de carnet de bord. Il détaille tout ce qui concerne le développement de l'application.
		
		\section{API}
			\label{api-dev}
			Le principe d'une API est de fournir au développeur une surcouche permettant d'encapsuler les calculs et représentations internes à l'intérieur 
			d'un certains nombre de méthodes. Ces méthodes seront par la suite utilisables par le développeur afin de faciliter l'implémentation. Un 
			diagramme de classes est disponible en annexe (cf page \pageref{fig:diagClass}).
			
			\subsection{La structue interne}
				Nous avons conçu trois structures C++, représentant respectivement les demi-arêtes, les points et les faces. Ces trois structures utilisées 
				ensemble définissent la représentation des maillages par demi-arêtes :
				\begin{verbatim}
					typedef struct HalfEdge {
						Vertex* vertex;
						Face* face;
						HalfEdge* next;
						HalfEdge* opposite;
						HalfEdge* previous;
					} HalfEdge;

					typedef struct Vertex {
						QVector3D coords;
						HalfEdge* outgoing;
						int index;
					} Vertex;

					typedef struct Face {
						HalfEdge* edge;
					} Face;
				\end{verbatim}
				Cette structure est certes relativement gourmande en stockage, mais très performante pour tous les algorithmes de transformations basés sur 
				le voisinage. Nous utilisons ici le voisinage non seulement pour le rendu, mais également dans chaque outil de sculpture et chaque fonction 
				telle que la subdivision. Nous avons d'ailleurs ajouté un entier dans la structure des points afin d'optenir des accès immédiats lors du 
				rendu.\\
				\\
				Pour utiliser cette structure tout en séparant bien les types d'interaction, nous avons créé un certain nombre de classes, dont chacune a un 
				rôle spécifique :
				\begin{itemize}
					\item \textbf{Mesh :} contient le maillage et toutes les méthodes de création de celui-ci (cf page \pageref{mesh-dev}).
					\item \textbf{MeshRenderer :} contient des buffer objects permettant le rendu d'un maillage (cf page \pageref{renderer-dev}).
					\item \textbf{MeshProcessing :} contient des méthodes statiques de modification de maillage (cf page \pageref{processing-dev}).
					\item \textbf{MeshTool :} contient les méthodes outils permettant la sculpture de l'objet (cf page \pageref{tool-dev}).
					\item \textbf{MeshManager :} contient et gère l'ensemble des objets de la scène (cf page \pageref{manager-dev}).
				\end{itemize}
				Toutes ces classes sont ensuite utilisées au sein de l'interface, notamment le widget OpenGL.
				
			\subsection{Les méthodes de la classe Mesh}
				\label{mesh-dev}
				\subsubsection{Génération des modèles prédéfinis}
					Comme expliqué précédemment (cf page \pageref{model-cdc}), nous avons plusieurs maillages prédéfinis. Pour chacun d'entre eux, 
					il existera une unique méthode, dans la classe Mesh, permettant de le générer :
					\begin{verbatim}
						void makeCone(float height, float radiusUp, float radiusDown, int discretization);
						void makeCube(float width, float height, float depth, int discretization);
						void makeCylinder(float height, float radius, int discretization);
						void makeSphere(float radius, int discretization);
						void makeTorus(float radiusH, float radiusV, int discretization);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres
					
				\subsubsection{Ajout d'une face}
					Il est possible de créer une face d'un maillage grâce à la fonction suivante :
					\begin{verbatim}
						bool addFace(QVector<QVector3D> vertices);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Découpage d'une arête}
					Il est possible de couper une arête en deux parts égales avec cette méthode :
					\begin{verbatim}
						bool cutEdge(QVector3D vertex1, QVector3D vertex2);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Fusion de deux arêtes}
					Il est possible de fusionner deux arêtes en une seule grâce à la fonction :
					\begin{verbatim}
						bool mergeEdge(QVector3D vertex1, QVector3D vertex2, QVector3D vertex3);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Récupération de points}
					Il est possible de récupérer une liste de points dans une certaine zone avec :
					\begin{verbatim}
						QVector<QVector3D> getVertices(QVector3D position, float areaSize);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Récupération de voisinage}
					Il est possible de récupérer une liste de points voisins d'un certain point avec :
					\begin{verbatim}
						QVector<QVector3D> getNeighbours(QVector3D vertex, int degree);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Récupération de normale de surface}
					Il est possible de récupérer la normale à la surface de l'objet grâce à la méthode :
					\begin{verbatim}
						QVector3D getNormal(QVector3D position);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Translation de points}
					Il est possible d'effectuer une translation sur un ou plusieurs points à l'aide des fonctions :
					\begin{verbatim}
						void moveVertex(QVector3D vertex, QVector3D move);
						void moveVertex(int index, QVector3D move);
						void moveVertices(QVector<QVector3D> vertices, QVector3D move);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Les accesseurs}
					La classe Mesh contient également certains accesseurs utiles :
					\begin{verbatim}
						QVector3D getCenter() const;
						void setCenter(QVector3D center);

						QVector3D getCoords(int index) const;
						void setCoords(QVector3D vertex, QVector3D coord);
						void setCoords(int index, QVector3D coord);

						int getEdgeCount() const;
						int getVertexCount() const;
						int getFaceCount() const;
					\end{verbatim}
					% TODO : explication brève
				
			\subsection{Les méthodes de la classe MeshRenderer}
				\label{renderer-dev}
				\subsubsection{Dessin de l'objet}
					On effectue le rendu OpenGL avec la méthode suivante :
					\begin{verbatim}
						void paintGL();
					\end{verbatim}
					% TODO : explication brève
					
				\subsubsection{Synchronisation des buffers}
					Il est parfois nécessaire d'actualiser ou non les buffers objects :
					\begin{verbatim}
						void update();
					\end{verbatim}
					% TODO : explication brève de comment ça marche
				
			\subsection{Les méthodes de la classe MeshProcessing}
				\label{processing-dev}
				\subsubsection{Subdivision}
					Nous avons mis en place deux types de subdivision :
					\begin{verbatim}
						static void subdivide(Mesh *mesh);
						static bool subdivideAuto(Mesh *mesh, float maxEdgeLength);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Décimation}
					Nous avons mis en place deux types de décimation :
					\begin{verbatim}
						static void decimate(Mesh *mesh);
						static bool decimateAuto(Mesh *mesh, float minEdgeLength);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
				
			\subsection{Les méthodes de la classe MeshTool}
				\label{tool-dev}
				\subsubsection{Les outils de sculpture}
					Comme expliqué précédemment (cf page \pageref{tool-cdc}), nous avons plusieurs outils de sculpture présents. Pour chacun d'entre eux, 
					il existera une unique méthode, dans la classe MeshTool, définissant son action :
					\begin{verbatim}
						void gtmove(Mesh *mesh, QVector3D move);
						void gtrotate(Mesh *mesh, QVector3D move);
						void gtscale(Mesh *mesh, QVector3D move);

						void ltadd(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
						void ltinflate(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
						void ltmove(Mesh *mesh, QPoint last_position, QVector3D move, float brushSize);
						void ltpinch(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
						void ltsmooth(Mesh *mesh, QPoint last_position, float brushSize, float strength, Qt::KeyboardModifiers modifiers);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Les outils spéciaux}
					De nouveaux outils, nommés ici "spéciaux", ont été développés suite à la proposition de notre encadrant :
					\begin{verbatim}
						void subdivideAuto(Mesh *mesh, QPoint last_position, float brushSize);
						void decimateAuto(Mesh *mesh, QPoint last_position, float brushSize);
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
				
			\subsection{Les méthodes de la classe MeshManager}
				\label{manager-dev}
				\subsubsection{Dessin et synchronisation}
					On effectue le rendu OpenGL et la synchronisation des buffers à l'aide de ces fonctions :
					\begin{verbatim}
						void paintGL(int activeMesh);
						void updateMesh(int index);
						void updateLastMesh();
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
					
				\subsubsection{Ajout et suppression}
					Puisque le MeshManager est un conteneur, il est possible d'ajouter ou de supprimer un ou plusieurs maillages :
					\begin{verbatim}
						void addMesh(Mesh *mesh);
						void removeMesh(Mesh *mesh);
						void clear();
					\end{verbatim}
					% TODO : explication brève de ce que représente les paramètres, comment ça marche
		
		\section{...}
			% TODO : diagrammes, problèmes et solutions, précisions (TRES TRES PEU DE CODE, PAS TROP UTILE SUR L'INTERFACE)...etc
			\subsection{...}

%==========================================================================================================================================================
	\chapter{Manuel}
		Ce chapitre détaille tout ce qui concerne l'utilisation de l'application, autant pour les utilisateurs que les développeurs souhaitant étendre les 
		possibilités du logiciel.
		
		\section{Utilisateur}
			% TODO : image de l'interface avec explications, raccourcis clavier, menus...etc

		\section{Développeur}
			Toute personne avec des bases de programmation pourra étendre les fonctionnalités de celle-ci grâce à notre API.
			
			\subsection{Ajout d'un maillage modèle}
				Il est possible d'ajouter un maillage modèle afin d'enrichir les objets de base proposés à l'utilisateur.
				%TODO : expliquer avec du code
				
			\subsection{Ajout d'un outil}
				Il est possible d'ajouter un maillage modèle afin d'enrichir les actions de sculpture proposéés à l'utilisateur.
				%TODO : expliquer avec du code
				
			\subsection{Pour aller plus loin...}
				Si un développeur souhaite modifier plus profondément l'application, il faudra pour cela se référer à la partie \textbf{Développement} (cf 
				page \pageref{dev}), notamment les explications détaillant l'\textbf{API} (cf page \pageref{api-dev}).

%==========================================================================================================================================================
	\chapter{Post-Mortem}
		Cette section liste toutes les étapes de la conception que nous n'avons pas réalisées (selon notre ordre de priorités), ainsi que toutes les améliorations auxquelles nous avons pensé lors de la phase de développement.
		
		\section{Fonctionnalités non implémentées}
			%TODO
			
		\section{Améliorations réalisables}
			%TODO

%==========================================================================================================================================================
	\appendix
	\chapter{}
		Dans cette partie seront placés les éléments trop volumineux pour être inclus directement dans le texte, tels que les images ou graphiques.\\
		
		\section{Diagramme de Gantt}
			Les diagrammes sont fournis page \pageref{fig:gantt}.
			
		\section{Comparatif de performances}
			Le graphique est situé page \pageref{fig:analyse}.
			
		\section{Diagramme de Classes}
			Le diagramme est fournis page \pageref{fig:diagClass}.
			
		\section*{}
			\begin{figure}
				\vspace{-3,5cm} \hspace{-4,5cm} \includegraphics[scale=0.6]{img/Gantt1.png}
				\vspace{-3,5cm} \hspace{-4,5cm} \includegraphics[scale=0.6]{img/Gantt2.png}
				\label{fig:gantt}
				\vspace{-0,5cm} \caption{Diagrammes de Gantt prédictif et final}
			\end{figure}
			
			\begin{figure}
				\begin{center}
					\includegraphics[scale=0.5]{img/AnalyseLangage1.png}
					\includegraphics[scale=0.5]{img/AnalyseLangage2.png} 
				\end{center}
				\label{fig:analyse}
				\caption{Comparaisons de performances de divers langages dans des cas donnés}
				Source : \url{http://attractivechaos.wordpress.com/2011/06/22/my-programming-language-benchmark-analyses/}
			\end{figure}
			
			\begin{figure}
				\begin{center}
					%\includegraphics[scale=0.5]{img/diagClass.png}
				\end{center}
				\label{fig:diagClass}
				\caption{Diagramme de classes de notre API}
			\end{figure}

\end{document}
